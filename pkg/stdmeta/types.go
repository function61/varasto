// "Standardized metadata" format
package stdmeta

import (
	"time"
)

// metadata for a single file, be it a:
// - .jpg of a personal photo or a funny meme
// - .pdf of a book, comic book or a magazine
// - .mp3 of podcast
// - .mkv of a movie, TV show or a YouTube video etc.
type Metadata struct {
	Title                 string            `json:"title,omitempty"`                   // title/subject/etc of this content
	Published             *time.Time        `json:"published,omitempty"`               // date(& time if known, if unknown use 00:00:00) when this content was first made available to an audience
	Description           string            `json:"description,omitempty"`             // anything not fitting in a title (that is not notes)
	Notes                 string            `json:"notes,omitempty"`                   // longer-form text, e.g. postcast episode notes
	Source                string            `json:"source,omitempty"`                  // where was this downloaded from, prefer user-centric URL (e.g. YouTube view URL) instead of the raw file. if you can, also set the identifier in e.g. Custom["youtube.com:video:id"]
	SourceTags            []string          `json:"tags_source,omitempty"`             // 1:1 as per the original source
	SourceCategories      []string          `json:"categories_source,omitempty"`       // 1:1 as per the original source
	SeasonEpisode         *SeasonEpisode    `json:"season_episode,omitempty"`          // if part of a numberable season (like TV show episodes)
	PagedSections         []PagedSection    `json:"paged_sections,omitempty"`          // description about pages/page ranges for paged media like books, magazines, comic books
	PageCount             *uint             `json:"page_count,omitempty"`              // do not be tempted to calculate this from "Pages" b/c it will be less accurate if all content isn't accounted for
	Annotations           []Annotation      `json:"annotations,omitempty"`             // time-based annotations (for content with a timeline) like video/audio
	AudioVideoContainer   *string           `json:"audio_video_container,omitempty"`   // which container format audio/video was inside in? "matroska" | "quicktime" | "asf" | "flv" | "avi" | "mpeg" | "mp3" | "flac" | ...
	VideoTrack            *VideoTrack       `json:"video_track,omitempty"`             // primary (usually the first) video track. if more (extremely uncommon), the rest are listed in additional tracks
	AdditionalVideoTracks []VideoTrack      `json:"video_tracks_additional,omitempty"` // see video_track
	AudioTracks           []AudioTrack      `json:"audio_tracks,omitempty"`
	SubtitleTracks        []SubtitleTrack   `json:"subtitle_tracks,omitempty"`
	Price                 *Money            `json:"price,omitempty"`   // (if known) price of a book, magazine issue etc (if multiple known, closest to publication moment)
	Budget                *Money            `json:"budget,omitempty"`  // budget of a movie, game etc.
	Revenue               *Money            `json:"revenue,omitempty"` // gross revenue generated by the movie, game etc.
	Custom                map[string]string `json:"custom,omitempty"`  // any custom key-value data like content identifiers

	DEPRECATED1 string `json:"season_and_episode_designation,omitempty"`
}

/*
	ffmpeg

	video codecs (codec_name):
	--------------


	audio codecs (same field as video's codec_name)
	--------------


	subtitle codecs (same field as video's codec_name)
	--------------

	container formats (format.format_name):
	--------------

*/

type Resolution struct {
	Width  uint `json:"width"`
	Height uint `json:"height"`
}

type VideoTrack struct {
	StreamIndex  uint       `json:"stream_index"` // 0-based within the container, per ffmpeg semantics
	Duration     uint64     `json:"duration"`     // [ms]
	Resolution   Resolution `json:"resolution"`
	Codec        string     `json:"codec"` // "hevc" | "h264" | "mjpeg" | "mpeg1video" | "mpeg4" | "wmv3" | ...
	CodecProfile string     `json:"codec_profile,omitempty"`
	BitRate      int        `json:"bit_rate"` // [bits/s]
	FrameRate    float64    `json:"frame_rate"`
}

type AudioTrack struct {
	StreamIndex   uint    `json:"stream_index"`       // 0-based within the container, per ffmpeg semantics
	Duration      uint64  `json:"duration"`           // [ms]
	Language      *string `json:"language,omitempty"` // same format as subtitle's language code
	Codec         string  `json:"codec"`              // "aac" | "mp3" | "mp2" | "wmav2" | "pcm_s16le" | ...
	CodecProfile  string  `json:"codec_profile,omitempty"`
	BitRate       *uint   `json:"bit_rate,omitempty"` // [bits/s]
	SampleRate    int     `json:"sample_rate"`        // [Hz]
	ChannelCount  int     `json:"channel_count"`
	ChannelLayout string  `json:"channel_layout,omitempty"`
}

type SubtitleTrack struct {
	StreamIndex uint    `json:"stream_index"` // 0-based within the container, per ffmpeg semantics
	Codec       string  `json:"codec"`        // "subrip" | "hdmv_pgs_subtitle" | ...
	Language    *string `json:"language"`     // 3-letter language code (ISO 639-2): "eng" | "fin" | ...
}

type Money struct {
	CurrencyCode string  `json:"currency_code"` // uppercased 3-letter currency code
	Amount       float64 `json:"amount"`
}

type PagedSection struct {
	Title           string            `json:"title"`
	Page            uint              `json:"page,omitempty"`            // (1-based) page number / start of page range if "page_end" defined
	PageEnd         *uint             `json:"page_end,omitempty"`        // if unset, it is not known if the title spans more than one page. if you're sure the title refers to one page only, specify same page!
	PageExclusions  []uint            `json:"page_exclusions,omitempty"` // to exclude unrelated content in the middle like ad pages, without complicating the page (start, end) mechanism too much
	Authors         []NameWithRoles   `json:"authors,omitempty"`         // authors for this section
	IsAdvertisement *bool             `json:"is_advertisement,omitempty"`
	Description     string            `json:"description,omitempty"`
	Custom          map[string]string `json:"custom,omitempty"`
	// HideFromTableOfContents bool `json:"hide_from_table_of_contents"`
}

type NameWithRoles struct {
	Name   string            `json:"name"`
	Roles  []string          `json:"roles,omitempty"` // optional
	Custom map[string]string `json:"custom"`          // optional, for identifiers (e.g. cast member ID) and such
}

// a labeled time position in a video or an audio stream, with an optional ending time
type Annotation struct {
	PositionMs    uint64  `json:"position_ms"`
	PositionEndMs *uint64 `json:"position_end_ms,omitempty"`
	Label         string  `json:"label"`
}

// if item is a TV episode
type SeasonEpisode struct {
	Season    *int `json:"season,omitempty"`     // TODO: why can this be empty???!
	Episode   *int `json:"episode,omitempty"`    // can be empty in rare cases, e.g. season specials
	EpisodeTo *int `json:"episode_to,omitempty"` // S03E06-07 => season=6 episode=6 episode_to=7
}
